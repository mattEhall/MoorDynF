!STARTOFREGISTRYGENERATEDFILE './MoorDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.03.02, 17-Sep-2014)
!*********************************************************************************************************************************
! MoorDyn_Types
!.................................................................................................................................
! This file is part of MoorDyn.
!
! Copyright (C) 2012-2014 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE MoorDyn_Types
! This module contains all of the user-defined types needed in MoorDyn. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  MD_InitInputType  =======
  TYPE, PUBLIC :: MD_InitInputType
    REAL(ReKi)  :: g = -999.9      ! gravity constant [[m/s^2]]
    REAL(ReKi)  :: rhoW = -999.9      ! sea density [[kg/m^3]]
    REAL(ReKi)  :: WtrDepth = -999.9      ! depth of water [[m]]
    REAL(ReKi) , DIMENSION(1:6)  :: PtfmInit      ! initial position of platform [-]
    CHARACTER(255)  :: FileName      ! MoorDyn input file [-]
    LOGICAL  :: Echo      ! echo parameter - do we want to echo the header line describing the input file? [-]
    REAL(ReKi)  :: DT      ! is this driver program time step size? [[s]]
    REAL(ReKi)  :: DTmooring      ! desired time step for mooring integration [[s]]
    REAL(ReKi)  :: DTIC      ! convergence check time step for IC generation [[s]]
    REAL(ReKi)  :: TMaxIC = 120      ! maximum time to allow for getting converged ICs [[s]]
    REAL(ReKi)  :: CdScaleIC = 1      ! factor to scale drag coefficients by during dynamic relaxation [[]]
    REAL(ReKi)  :: threshIC = 0.01      ! convergence tolerance for ICs  (0.01 means 1%) [[]]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: OutList      ! string containing list of output channels requested in input file [-]
    INTEGER(IntKi)  :: NumOuts      !  [-]
  END TYPE MD_InitInputType
! =======================
! =========  MD_LineProp  =======
  TYPE, PUBLIC :: MD_LineProp
    INTEGER(IntKi)  :: IdNum      ! integer identifier of this set of line properties [-]
    CHARACTER(10)  :: name      ! name/identifier of this set of line properties [-]
    REAL(ReKi)  :: d      ! volume-equivalent diameter [[m]]
    REAL(ReKi)  :: w      ! per-length weight in air [[kg/m]]
    REAL(ReKi)  :: EA      ! stiffness [[N]]
    REAL(ReKi)  :: BA      ! internal damping coefficient times area [[N-s]]
    REAL(ReKi)  :: Can      ! transverse added mass coefficient [-]
    REAL(ReKi)  :: Cat      ! tangential added mass coefficient [-]
    REAL(ReKi)  :: Cdn      ! transverse drag coefficient [-]
    REAL(ReKi)  :: Cdt      ! tangential drag coefficient [-]
  END TYPE MD_LineProp
! =======================
! =========  MD_Connect  =======
  TYPE, PUBLIC :: MD_Connect
    INTEGER(IntKi)  :: IdNum      ! integer identifier of this Connection [-]
    CHARACTER(10)  :: type      ! type of Connect: fix, vessel, connect [-]
    INTEGER(IntKi)  :: TypeNum      ! integer identifying the type.  0=fixed, 1=vessel, 2=connect [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: AttachedFairs      ! list of IdNums of connected Line tops [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: AttachedAnchs      ! list of IdNums of connected Line bottoms [-]
    REAL(ReKi)  :: conX      !  [-]
    REAL(ReKi)  :: conY      !  [-]
    REAL(ReKi)  :: conZ      !  [-]
    REAL(ReKi)  :: conM      !  [-]
    REAL(ReKi)  :: conV      !  [-]
    REAL(ReKi)  :: conFX      !  [-]
    REAL(ReKi)  :: conFY      !  [-]
    REAL(ReKi)  :: conFZ      !  [-]
    REAL(ReKi) , DIMENSION(1:3)  :: Ftot      ! total force on node [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: Mtot      ! node mass matrix, from attached lines [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: S      ! inverse mass matrix [[kg]]
    REAL(ReKi) , DIMENSION(1:3)  :: r      ! position [-]
    REAL(ReKi) , DIMENSION(1:3)  :: rd      ! velocity [-]
  END TYPE MD_Connect
! =======================
! =========  MD_Line  =======
  TYPE, PUBLIC :: MD_Line
    INTEGER(IntKi)  :: IdNum      ! integer identifier of this Line [-]
    CHARACTER(10)  :: type      ! type of line.  should match one of LineProp names [-]
    CHARACTER(10)  :: OutFlags      ! string specifying output options and other flags [-]
    INTEGER(IntKi)  :: FairConnect      ! IdNum of Connection at fairlead [-]
    INTEGER(IntKi)  :: AnchConnect      ! IdNum of Connection at anchor [-]
    INTEGER(IntKi)  :: PropsIdNum      ! the IdNum of the associated line properties [-]
    INTEGER(IntKi)  :: N      ! The number of elements in the line [-]
    REAL(ReKi)  :: UnstrLen      ! unstretched length of the line [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: r      ! node positions [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: rd      ! node velocities [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: q      ! node tangent vectors [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: l      ! segment unstretched length [[m]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: lstr      ! segment stretched length [[m]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: lstrd      ! segment change in stretched length [[m/s]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: V      ! segment volume [[m^3]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: T      ! segment tension vectors [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Td      ! segment internal damping force vectors [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: W      ! weight/buoyancy vectors [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Dp      ! node drag (transverse) [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Dq      ! node drag (axial) [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Ap      ! node added mass forcing (transverse) [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Aq      ! node added mass forcing (axial) [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: B      ! node bottom contact force [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F      ! total force on node [[N]]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: S      ! node inverse mass matrix [[kg]]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: M      ! node mass matrix [[kg]]
  END TYPE MD_Line
! =======================
! =========  MD_OutParmType  =======
  TYPE, PUBLIC :: MD_OutParmType
    CHARACTER(10)  :: Name      ! name of output channel [-]
    CHARACTER(10)  :: Units      ! units string [-]
    INTEGER(IntKi)  :: QType      ! type of quantity - 0=tension, 1=x, 2=y, 3=z... [-]
    INTEGER(IntKi)  :: OType      ! type of object - 0=line, 1=connect [-]
    INTEGER(IntKi)  :: NodeID      ! node number if OType=0.  0=anchor, -1=N=Fairlead [-]
    INTEGER(IntKi)  :: ObjID      ! number of Connect or Line object [-]
  END TYPE MD_OutParmType
! =======================
! =========  MD_InitOutputType  =======
  TYPE, PUBLIC :: MD_InitOutputType
    CHARACTER(99)  :: progName      ! program name [-]
    CHARACTER(99)  :: version      ! version numnber [-]
    CHARACTER(24)  :: compilingData      ! compiling data [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: writeOutputHdr      ! first line output file contents: output variable names [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: writeOutputUnt      ! second line of output file contents: units [-]
    TYPE(ProgDesc)  :: Ver      ! his module's name, version, and date [-]
  END TYPE MD_InitOutputType
! =======================
! =========  MD_ContinuousStateType  =======
  TYPE, PUBLIC :: MD_ContinuousStateType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: states      ! full list of node coordinates and velocities [[m] or [m/s]]
  END TYPE MD_ContinuousStateType
! =======================
! =========  MD_DiscreteStateType  =======
  TYPE, PUBLIC :: MD_DiscreteStateType
    REAL(ReKi)  :: dummy      ! Remove this variable if you have discrete states [-]
  END TYPE MD_DiscreteStateType
! =======================
! =========  MD_OtherStateType  =======
  TYPE, PUBLIC :: MD_OtherStateType
    TYPE(MD_LineProp) , DIMENSION(:), ALLOCATABLE  :: LineTypeList      ! array of properties for each line type [-]
    TYPE(MD_Connect) , DIMENSION(:), ALLOCATABLE  :: ConnectList      ! array of connection properties [-]
    TYPE(MD_Line) , DIMENSION(:), ALLOCATABLE  :: LineList      ! array of line properties [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FairIdList      ! array of size NFairs listing the ID of each fairlead (index of ConnectList) []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: LineStateIndList      ! starting index of each line's states in state vector []
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F      ! thing for RK2 calculation, same size as states [[m] or [m/s]]
  END TYPE MD_OtherStateType
! =======================
! =========  MD_ConstraintStateType  =======
  TYPE, PUBLIC :: MD_ConstraintStateType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dummy      ! @MH: I don't think my model needs anything here [-]
  END TYPE MD_ConstraintStateType
! =======================
! =========  MD_ParameterType  =======
  TYPE, PUBLIC :: MD_ParameterType
    INTEGER(IntKi)  :: NTypes      ! number of line types []
    INTEGER(IntKi)  :: NConnects      ! number of Connection objects []
    INTEGER(IntKi)  :: NLines      ! number of Line objects []
    INTEGER(IntKi)  :: NFairs      ! number of Fairlead Connections []
    REAL(ReKi)  :: g = 9.81      ! gravitational constant [[kg/m^2]]
    REAL(ReKi)  :: rhoW      ! density of seawater [[m]]
    REAL(ReKi)  :: WtrDpth      ! water depth [[m]]
    REAL(ReKi)  :: kBot      ! bottom stiffness [[Pa/m]]
    REAL(ReKi)  :: cBot      ! bottom damping [[Pa-s/m]]
    REAL(ReKi)  :: dt      ! mooring model time step [[s]]
    REAL(ReKi)  :: dtCoupling      ! coupling time step [[s]]
    INTEGER(IntKi)  :: Ndt      ! number of mooring time steps per coupling time step [[]]
    INTEGER(IntKi)  :: NumOuts      ! Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(1024)  :: RootName      ! RootName for writing output files [-]
    TYPE(MD_OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      ! Names and units (and other characteristics) of all requested output parameters [-]
    CHARACTER(1)  :: Delim      ! Column delimiter for output text files [-]
  END TYPE MD_ParameterType
! =======================
! =========  MD_InputType  =======
  TYPE, PUBLIC :: MD_InputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: x      ! Connect x displacement [[m] - using these to temporarily hold initial Connect locations]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: y      ! Connect y displacement [[m]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: z      ! Connect z displacement [[m]]
    TYPE(MeshType)  :: PtFairleadDisplacement      ! position of each fairlead in X,Y,Z [[m]]
  END TYPE MD_InputType
! =======================
! =========  MD_OutputType  =======
  TYPE, PUBLIC :: MD_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Fx      ! horizontal line force [[N]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Fy      ! Vertical line force [[N]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Fz      ! horizontal line force at anchor [[N]]
    TYPE(MeshType)  :: PtFairleadLoad      ! point mesh for forces in X,Y,Z [[N]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      ! output vector returned to glue code []
  END TYPE MD_OutputType
! =======================
CONTAINS
 SUBROUTINE MD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_initinputtype), INTENT(INOUT) :: SrcInitInputData
   TYPE(MD_initinputtype), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%g = SrcInitInputData%g
   DstInitInputData%rhoW = SrcInitInputData%rhoW
   DstInitInputData%WtrDepth = SrcInitInputData%WtrDepth
   DstInitInputData%PtfmInit = SrcInitInputData%PtfmInit
   DstInitInputData%FileName = SrcInitInputData%FileName
   DstInitInputData%Echo = SrcInitInputData%Echo
   DstInitInputData%DT = SrcInitInputData%DT
   DstInitInputData%DTmooring = SrcInitInputData%DTmooring
   DstInitInputData%DTIC = SrcInitInputData%DTIC
   DstInitInputData%TMaxIC = SrcInitInputData%TMaxIC
   DstInitInputData%CdScaleIC = SrcInitInputData%CdScaleIC
   DstInitInputData%threshIC = SrcInitInputData%threshIC
IF (ALLOCATED(SrcInitInputData%OutList)) THEN
   i1_l = LBOUND(SrcInitInputData%OutList,1)
   i1_u = UBOUND(SrcInitInputData%OutList,1)
   IF (.NOT. ALLOCATED(DstInitInputData%OutList)) THEN 
      ALLOCATE(DstInitInputData%OutList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyInitInput: Error allocating DstInitInputData%OutList.'
         RETURN
      END IF
   END IF
   DstInitInputData%OutList = SrcInitInputData%OutList
ENDIF
   DstInitInputData%NumOuts = SrcInitInputData%NumOuts
 END SUBROUTINE MD_CopyInitInput

 SUBROUTINE MD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(MD_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%OutList)) THEN
   DEALLOCATE(InitInputData%OutList)
ENDIF
 END SUBROUTINE MD_DestroyInitInput

 SUBROUTINE MD_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! g
  Re_BufSz   = Re_BufSz   + 1  ! rhoW
  Re_BufSz   = Re_BufSz   + 1  ! WtrDepth
  Re_BufSz    = Re_BufSz    + SIZE( InData%PtfmInit )  ! PtfmInit 
  Re_BufSz   = Re_BufSz   + 1  ! DT
  Re_BufSz   = Re_BufSz   + 1  ! DTmooring
  Re_BufSz   = Re_BufSz   + 1  ! DTIC
  Re_BufSz   = Re_BufSz   + 1  ! TMaxIC
  Re_BufSz   = Re_BufSz   + 1  ! CdScaleIC
  Re_BufSz   = Re_BufSz   + 1  ! threshIC
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%g )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%rhoW )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDepth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PtfmInit))-1 ) =  PACK(InData%PtfmInit ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PtfmInit)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DT )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DTmooring )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DTIC )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TMaxIC )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%CdScaleIC )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%threshIC )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE MD_PackInitInput

 SUBROUTINE MD_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%g = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%rhoW = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDepth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%PtfmInit,1))); mask1 = .TRUE.
  OutData%PtfmInit = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PtfmInit))-1 ),mask1,OutData%PtfmInit)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PtfmInit)
  OutData%DT = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DTmooring = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DTIC = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TMaxIC = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%CdScaleIC = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%threshIC = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackInitInput

 SUBROUTINE MD_Copylineprop( SrclinepropData, DstlinepropData, CtrlCode, ErrStat, ErrMsg )
   TYPE(md_lineprop), INTENT(INOUT) :: SrclinepropData
   TYPE(md_lineprop), INTENT(INOUT) :: DstlinepropData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstlinepropData%IdNum = SrclinepropData%IdNum
   DstlinepropData%name = SrclinepropData%name
   DstlinepropData%d = SrclinepropData%d
   DstlinepropData%w = SrclinepropData%w
   DstlinepropData%EA = SrclinepropData%EA
   DstlinepropData%BA = SrclinepropData%BA
   DstlinepropData%Can = SrclinepropData%Can
   DstlinepropData%Cat = SrclinepropData%Cat
   DstlinepropData%Cdn = SrclinepropData%Cdn
   DstlinepropData%Cdt = SrclinepropData%Cdt
 END SUBROUTINE MD_Copylineprop

 SUBROUTINE MD_Destroylineprop( linepropData, ErrStat, ErrMsg )
  TYPE(md_lineprop), INTENT(INOUT) :: linepropData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MD_Destroylineprop

 SUBROUTINE MD_Packlineprop( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(md_lineprop),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! IdNum
  Re_BufSz   = Re_BufSz   + 1  ! d
  Re_BufSz   = Re_BufSz   + 1  ! w
  Re_BufSz   = Re_BufSz   + 1  ! EA
  Re_BufSz   = Re_BufSz   + 1  ! BA
  Re_BufSz   = Re_BufSz   + 1  ! Can
  Re_BufSz   = Re_BufSz   + 1  ! Cat
  Re_BufSz   = Re_BufSz   + 1  ! Cdn
  Re_BufSz   = Re_BufSz   + 1  ! Cdt
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IdNum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%d )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%w )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%EA )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%BA )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Can )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cat )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cdn )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cdt )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE MD_Packlineprop

 SUBROUTINE MD_UnPacklineprop( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(md_lineprop), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%IdNum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%d = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%w = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%EA = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%BA = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Can = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cat = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cdn = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cdt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPacklineprop

 SUBROUTINE MD_Copyconnect( SrcconnectData, DstconnectData, CtrlCode, ErrStat, ErrMsg )
   TYPE(md_connect), INTENT(INOUT) :: SrcconnectData
   TYPE(md_connect), INTENT(INOUT) :: DstconnectData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstconnectData%IdNum = SrcconnectData%IdNum
   DstconnectData%type = SrcconnectData%type
   DstconnectData%TypeNum = SrcconnectData%TypeNum
IF (ALLOCATED(SrcconnectData%AttachedFairs)) THEN
   i1_l = LBOUND(SrcconnectData%AttachedFairs,1)
   i1_u = UBOUND(SrcconnectData%AttachedFairs,1)
   IF (.NOT. ALLOCATED(DstconnectData%AttachedFairs)) THEN 
      ALLOCATE(DstconnectData%AttachedFairs(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyconnect: Error allocating DstconnectData%AttachedFairs.'
         RETURN
      END IF
   END IF
   DstconnectData%AttachedFairs = SrcconnectData%AttachedFairs
ENDIF
IF (ALLOCATED(SrcconnectData%AttachedAnchs)) THEN
   i1_l = LBOUND(SrcconnectData%AttachedAnchs,1)
   i1_u = UBOUND(SrcconnectData%AttachedAnchs,1)
   IF (.NOT. ALLOCATED(DstconnectData%AttachedAnchs)) THEN 
      ALLOCATE(DstconnectData%AttachedAnchs(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyconnect: Error allocating DstconnectData%AttachedAnchs.'
         RETURN
      END IF
   END IF
   DstconnectData%AttachedAnchs = SrcconnectData%AttachedAnchs
ENDIF
   DstconnectData%conX = SrcconnectData%conX
   DstconnectData%conY = SrcconnectData%conY
   DstconnectData%conZ = SrcconnectData%conZ
   DstconnectData%conM = SrcconnectData%conM
   DstconnectData%conV = SrcconnectData%conV
   DstconnectData%conFX = SrcconnectData%conFX
   DstconnectData%conFY = SrcconnectData%conFY
   DstconnectData%conFZ = SrcconnectData%conFZ
   DstconnectData%Ftot = SrcconnectData%Ftot
   DstconnectData%Mtot = SrcconnectData%Mtot
   DstconnectData%S = SrcconnectData%S
   DstconnectData%r = SrcconnectData%r
   DstconnectData%rd = SrcconnectData%rd
 END SUBROUTINE MD_Copyconnect

 SUBROUTINE MD_Destroyconnect( connectData, ErrStat, ErrMsg )
  TYPE(md_connect), INTENT(INOUT) :: connectData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(connectData%AttachedFairs)) THEN
   DEALLOCATE(connectData%AttachedFairs)
ENDIF
IF (ALLOCATED(connectData%AttachedAnchs)) THEN
   DEALLOCATE(connectData%AttachedAnchs)
ENDIF
 END SUBROUTINE MD_Destroyconnect

 SUBROUTINE MD_Packconnect( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(md_connect),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! IdNum
  Int_BufSz  = Int_BufSz  + 1  ! TypeNum
  Int_BufSz   = Int_BufSz   + SIZE( InData%AttachedFairs )  ! AttachedFairs 
  Int_BufSz   = Int_BufSz   + SIZE( InData%AttachedAnchs )  ! AttachedAnchs 
  Re_BufSz   = Re_BufSz   + 1  ! conX
  Re_BufSz   = Re_BufSz   + 1  ! conY
  Re_BufSz   = Re_BufSz   + 1  ! conZ
  Re_BufSz   = Re_BufSz   + 1  ! conM
  Re_BufSz   = Re_BufSz   + 1  ! conV
  Re_BufSz   = Re_BufSz   + 1  ! conFX
  Re_BufSz   = Re_BufSz   + 1  ! conFY
  Re_BufSz   = Re_BufSz   + 1  ! conFZ
  Re_BufSz    = Re_BufSz    + SIZE( InData%Ftot )  ! Ftot 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Mtot )  ! Mtot 
  Re_BufSz    = Re_BufSz    + SIZE( InData%S )  ! S 
  Re_BufSz    = Re_BufSz    + SIZE( InData%r )  ! r 
  Re_BufSz    = Re_BufSz    + SIZE( InData%rd )  ! rd 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IdNum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TypeNum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%AttachedFairs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AttachedFairs))-1 ) = PACK(InData%AttachedFairs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AttachedFairs)
  ENDIF
  IF ( ALLOCATED(InData%AttachedAnchs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AttachedAnchs))-1 ) = PACK(InData%AttachedAnchs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AttachedAnchs)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conX )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conY )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conZ )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conM )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conV )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conFX )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conFY )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conFZ )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ftot))-1 ) =  PACK(InData%Ftot ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Ftot)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Mtot))-1 ) =  PACK(InData%Mtot ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Mtot)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%S))-1 ) =  PACK(InData%S ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%S)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%r))-1 ) =  PACK(InData%r ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%r)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rd))-1 ) =  PACK(InData%rd ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%rd)
 END SUBROUTINE MD_Packconnect

 SUBROUTINE MD_UnPackconnect( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(md_connect), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%IdNum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TypeNum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%AttachedFairs) ) THEN
  ALLOCATE(mask1(SIZE(OutData%AttachedFairs,1))); mask1 = .TRUE.
    OutData%AttachedFairs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AttachedFairs))-1 ),mask1,OutData%AttachedFairs)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AttachedFairs)
  ENDIF
  IF ( ALLOCATED(OutData%AttachedAnchs) ) THEN
  ALLOCATE(mask1(SIZE(OutData%AttachedAnchs,1))); mask1 = .TRUE.
    OutData%AttachedAnchs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AttachedAnchs))-1 ),mask1,OutData%AttachedAnchs)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AttachedAnchs)
  ENDIF
  OutData%conX = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conY = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conZ = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conM = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conV = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conFX = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conFY = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conFZ = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%Ftot,1))); mask1 = .TRUE.
  OutData%Ftot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ftot))-1 ),mask1,OutData%Ftot)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Ftot)
  ALLOCATE(mask2(SIZE(OutData%Mtot,1),SIZE(OutData%Mtot,2))); mask2 = .TRUE.
  OutData%Mtot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Mtot))-1 ),mask2,OutData%Mtot)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Mtot)
  ALLOCATE(mask2(SIZE(OutData%S,1),SIZE(OutData%S,2))); mask2 = .TRUE.
  OutData%S = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%S))-1 ),mask2,OutData%S)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%S)
  ALLOCATE(mask1(SIZE(OutData%r,1))); mask1 = .TRUE.
  OutData%r = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%r))-1 ),mask1,OutData%r)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%r)
  ALLOCATE(mask1(SIZE(OutData%rd,1))); mask1 = .TRUE.
  OutData%rd = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rd))-1 ),mask1,OutData%rd)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%rd)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackconnect

 SUBROUTINE MD_Copyline( SrclineData, DstlineData, CtrlCode, ErrStat, ErrMsg )
   TYPE(md_line), INTENT(INOUT) :: SrclineData
   TYPE(md_line), INTENT(INOUT) :: DstlineData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstlineData%IdNum = SrclineData%IdNum
   DstlineData%type = SrclineData%type
   DstlineData%OutFlags = SrclineData%OutFlags
   DstlineData%FairConnect = SrclineData%FairConnect
   DstlineData%AnchConnect = SrclineData%AnchConnect
   DstlineData%PropsIdNum = SrclineData%PropsIdNum
   DstlineData%N = SrclineData%N
   DstlineData%UnstrLen = SrclineData%UnstrLen
IF (ALLOCATED(SrclineData%r)) THEN
   i1_l = LBOUND(SrclineData%r,1)
   i1_u = UBOUND(SrclineData%r,1)
   i2_l = LBOUND(SrclineData%r,2)
   i2_u = UBOUND(SrclineData%r,2)
   IF (.NOT. ALLOCATED(DstlineData%r)) THEN 
      ALLOCATE(DstlineData%r(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%r.'
         RETURN
      END IF
   END IF
   DstlineData%r = SrclineData%r
ENDIF
IF (ALLOCATED(SrclineData%rd)) THEN
   i1_l = LBOUND(SrclineData%rd,1)
   i1_u = UBOUND(SrclineData%rd,1)
   i2_l = LBOUND(SrclineData%rd,2)
   i2_u = UBOUND(SrclineData%rd,2)
   IF (.NOT. ALLOCATED(DstlineData%rd)) THEN 
      ALLOCATE(DstlineData%rd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%rd.'
         RETURN
      END IF
   END IF
   DstlineData%rd = SrclineData%rd
ENDIF
IF (ALLOCATED(SrclineData%q)) THEN
   i1_l = LBOUND(SrclineData%q,1)
   i1_u = UBOUND(SrclineData%q,1)
   i2_l = LBOUND(SrclineData%q,2)
   i2_u = UBOUND(SrclineData%q,2)
   IF (.NOT. ALLOCATED(DstlineData%q)) THEN 
      ALLOCATE(DstlineData%q(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%q.'
         RETURN
      END IF
   END IF
   DstlineData%q = SrclineData%q
ENDIF
IF (ALLOCATED(SrclineData%l)) THEN
   i1_l = LBOUND(SrclineData%l,1)
   i1_u = UBOUND(SrclineData%l,1)
   IF (.NOT. ALLOCATED(DstlineData%l)) THEN 
      ALLOCATE(DstlineData%l(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%l.'
         RETURN
      END IF
   END IF
   DstlineData%l = SrclineData%l
ENDIF
IF (ALLOCATED(SrclineData%lstr)) THEN
   i1_l = LBOUND(SrclineData%lstr,1)
   i1_u = UBOUND(SrclineData%lstr,1)
   IF (.NOT. ALLOCATED(DstlineData%lstr)) THEN 
      ALLOCATE(DstlineData%lstr(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%lstr.'
         RETURN
      END IF
   END IF
   DstlineData%lstr = SrclineData%lstr
ENDIF
IF (ALLOCATED(SrclineData%lstrd)) THEN
   i1_l = LBOUND(SrclineData%lstrd,1)
   i1_u = UBOUND(SrclineData%lstrd,1)
   IF (.NOT. ALLOCATED(DstlineData%lstrd)) THEN 
      ALLOCATE(DstlineData%lstrd(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%lstrd.'
         RETURN
      END IF
   END IF
   DstlineData%lstrd = SrclineData%lstrd
ENDIF
IF (ALLOCATED(SrclineData%V)) THEN
   i1_l = LBOUND(SrclineData%V,1)
   i1_u = UBOUND(SrclineData%V,1)
   IF (.NOT. ALLOCATED(DstlineData%V)) THEN 
      ALLOCATE(DstlineData%V(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%V.'
         RETURN
      END IF
   END IF
   DstlineData%V = SrclineData%V
ENDIF
IF (ALLOCATED(SrclineData%T)) THEN
   i1_l = LBOUND(SrclineData%T,1)
   i1_u = UBOUND(SrclineData%T,1)
   i2_l = LBOUND(SrclineData%T,2)
   i2_u = UBOUND(SrclineData%T,2)
   IF (.NOT. ALLOCATED(DstlineData%T)) THEN 
      ALLOCATE(DstlineData%T(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%T.'
         RETURN
      END IF
   END IF
   DstlineData%T = SrclineData%T
ENDIF
IF (ALLOCATED(SrclineData%Td)) THEN
   i1_l = LBOUND(SrclineData%Td,1)
   i1_u = UBOUND(SrclineData%Td,1)
   i2_l = LBOUND(SrclineData%Td,2)
   i2_u = UBOUND(SrclineData%Td,2)
   IF (.NOT. ALLOCATED(DstlineData%Td)) THEN 
      ALLOCATE(DstlineData%Td(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%Td.'
         RETURN
      END IF
   END IF
   DstlineData%Td = SrclineData%Td
ENDIF
IF (ALLOCATED(SrclineData%W)) THEN
   i1_l = LBOUND(SrclineData%W,1)
   i1_u = UBOUND(SrclineData%W,1)
   i2_l = LBOUND(SrclineData%W,2)
   i2_u = UBOUND(SrclineData%W,2)
   IF (.NOT. ALLOCATED(DstlineData%W)) THEN 
      ALLOCATE(DstlineData%W(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%W.'
         RETURN
      END IF
   END IF
   DstlineData%W = SrclineData%W
ENDIF
IF (ALLOCATED(SrclineData%Dp)) THEN
   i1_l = LBOUND(SrclineData%Dp,1)
   i1_u = UBOUND(SrclineData%Dp,1)
   i2_l = LBOUND(SrclineData%Dp,2)
   i2_u = UBOUND(SrclineData%Dp,2)
   IF (.NOT. ALLOCATED(DstlineData%Dp)) THEN 
      ALLOCATE(DstlineData%Dp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%Dp.'
         RETURN
      END IF
   END IF
   DstlineData%Dp = SrclineData%Dp
ENDIF
IF (ALLOCATED(SrclineData%Dq)) THEN
   i1_l = LBOUND(SrclineData%Dq,1)
   i1_u = UBOUND(SrclineData%Dq,1)
   i2_l = LBOUND(SrclineData%Dq,2)
   i2_u = UBOUND(SrclineData%Dq,2)
   IF (.NOT. ALLOCATED(DstlineData%Dq)) THEN 
      ALLOCATE(DstlineData%Dq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%Dq.'
         RETURN
      END IF
   END IF
   DstlineData%Dq = SrclineData%Dq
ENDIF
IF (ALLOCATED(SrclineData%Ap)) THEN
   i1_l = LBOUND(SrclineData%Ap,1)
   i1_u = UBOUND(SrclineData%Ap,1)
   i2_l = LBOUND(SrclineData%Ap,2)
   i2_u = UBOUND(SrclineData%Ap,2)
   IF (.NOT. ALLOCATED(DstlineData%Ap)) THEN 
      ALLOCATE(DstlineData%Ap(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%Ap.'
         RETURN
      END IF
   END IF
   DstlineData%Ap = SrclineData%Ap
ENDIF
IF (ALLOCATED(SrclineData%Aq)) THEN
   i1_l = LBOUND(SrclineData%Aq,1)
   i1_u = UBOUND(SrclineData%Aq,1)
   i2_l = LBOUND(SrclineData%Aq,2)
   i2_u = UBOUND(SrclineData%Aq,2)
   IF (.NOT. ALLOCATED(DstlineData%Aq)) THEN 
      ALLOCATE(DstlineData%Aq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%Aq.'
         RETURN
      END IF
   END IF
   DstlineData%Aq = SrclineData%Aq
ENDIF
IF (ALLOCATED(SrclineData%B)) THEN
   i1_l = LBOUND(SrclineData%B,1)
   i1_u = UBOUND(SrclineData%B,1)
   i2_l = LBOUND(SrclineData%B,2)
   i2_u = UBOUND(SrclineData%B,2)
   IF (.NOT. ALLOCATED(DstlineData%B)) THEN 
      ALLOCATE(DstlineData%B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%B.'
         RETURN
      END IF
   END IF
   DstlineData%B = SrclineData%B
ENDIF
IF (ALLOCATED(SrclineData%F)) THEN
   i1_l = LBOUND(SrclineData%F,1)
   i1_u = UBOUND(SrclineData%F,1)
   i2_l = LBOUND(SrclineData%F,2)
   i2_u = UBOUND(SrclineData%F,2)
   IF (.NOT. ALLOCATED(DstlineData%F)) THEN 
      ALLOCATE(DstlineData%F(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%F.'
         RETURN
      END IF
   END IF
   DstlineData%F = SrclineData%F
ENDIF
IF (ALLOCATED(SrclineData%S)) THEN
   i1_l = LBOUND(SrclineData%S,1)
   i1_u = UBOUND(SrclineData%S,1)
   i2_l = LBOUND(SrclineData%S,2)
   i2_u = UBOUND(SrclineData%S,2)
   i3_l = LBOUND(SrclineData%S,3)
   i3_u = UBOUND(SrclineData%S,3)
   IF (.NOT. ALLOCATED(DstlineData%S)) THEN 
      ALLOCATE(DstlineData%S(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%S.'
         RETURN
      END IF
   END IF
   DstlineData%S = SrclineData%S
ENDIF
IF (ALLOCATED(SrclineData%M)) THEN
   i1_l = LBOUND(SrclineData%M,1)
   i1_u = UBOUND(SrclineData%M,1)
   i2_l = LBOUND(SrclineData%M,2)
   i2_u = UBOUND(SrclineData%M,2)
   i3_l = LBOUND(SrclineData%M,3)
   i3_u = UBOUND(SrclineData%M,3)
   IF (.NOT. ALLOCATED(DstlineData%M)) THEN 
      ALLOCATE(DstlineData%M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_Copyline: Error allocating DstlineData%M.'
         RETURN
      END IF
   END IF
   DstlineData%M = SrclineData%M
ENDIF
 END SUBROUTINE MD_Copyline

 SUBROUTINE MD_Destroyline( lineData, ErrStat, ErrMsg )
  TYPE(md_line), INTENT(INOUT) :: lineData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(lineData%r)) THEN
   DEALLOCATE(lineData%r)
ENDIF
IF (ALLOCATED(lineData%rd)) THEN
   DEALLOCATE(lineData%rd)
ENDIF
IF (ALLOCATED(lineData%q)) THEN
   DEALLOCATE(lineData%q)
ENDIF
IF (ALLOCATED(lineData%l)) THEN
   DEALLOCATE(lineData%l)
ENDIF
IF (ALLOCATED(lineData%lstr)) THEN
   DEALLOCATE(lineData%lstr)
ENDIF
IF (ALLOCATED(lineData%lstrd)) THEN
   DEALLOCATE(lineData%lstrd)
ENDIF
IF (ALLOCATED(lineData%V)) THEN
   DEALLOCATE(lineData%V)
ENDIF
IF (ALLOCATED(lineData%T)) THEN
   DEALLOCATE(lineData%T)
ENDIF
IF (ALLOCATED(lineData%Td)) THEN
   DEALLOCATE(lineData%Td)
ENDIF
IF (ALLOCATED(lineData%W)) THEN
   DEALLOCATE(lineData%W)
ENDIF
IF (ALLOCATED(lineData%Dp)) THEN
   DEALLOCATE(lineData%Dp)
ENDIF
IF (ALLOCATED(lineData%Dq)) THEN
   DEALLOCATE(lineData%Dq)
ENDIF
IF (ALLOCATED(lineData%Ap)) THEN
   DEALLOCATE(lineData%Ap)
ENDIF
IF (ALLOCATED(lineData%Aq)) THEN
   DEALLOCATE(lineData%Aq)
ENDIF
IF (ALLOCATED(lineData%B)) THEN
   DEALLOCATE(lineData%B)
ENDIF
IF (ALLOCATED(lineData%F)) THEN
   DEALLOCATE(lineData%F)
ENDIF
IF (ALLOCATED(lineData%S)) THEN
   DEALLOCATE(lineData%S)
ENDIF
IF (ALLOCATED(lineData%M)) THEN
   DEALLOCATE(lineData%M)
ENDIF
 END SUBROUTINE MD_Destroyline

 SUBROUTINE MD_Packline( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(md_line),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! IdNum
  Int_BufSz  = Int_BufSz  + 1  ! FairConnect
  Int_BufSz  = Int_BufSz  + 1  ! AnchConnect
  Int_BufSz  = Int_BufSz  + 1  ! PropsIdNum
  Int_BufSz  = Int_BufSz  + 1  ! N
  Re_BufSz   = Re_BufSz   + 1  ! UnstrLen
  Re_BufSz    = Re_BufSz    + SIZE( InData%r )  ! r 
  Re_BufSz    = Re_BufSz    + SIZE( InData%rd )  ! rd 
  Re_BufSz    = Re_BufSz    + SIZE( InData%q )  ! q 
  Re_BufSz    = Re_BufSz    + SIZE( InData%l )  ! l 
  Re_BufSz    = Re_BufSz    + SIZE( InData%lstr )  ! lstr 
  Re_BufSz    = Re_BufSz    + SIZE( InData%lstrd )  ! lstrd 
  Re_BufSz    = Re_BufSz    + SIZE( InData%V )  ! V 
  Re_BufSz    = Re_BufSz    + SIZE( InData%T )  ! T 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Td )  ! Td 
  Re_BufSz    = Re_BufSz    + SIZE( InData%W )  ! W 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Dp )  ! Dp 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Dq )  ! Dq 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Ap )  ! Ap 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Aq )  ! Aq 
  Re_BufSz    = Re_BufSz    + SIZE( InData%B )  ! B 
  Re_BufSz    = Re_BufSz    + SIZE( InData%F )  ! F 
  Re_BufSz    = Re_BufSz    + SIZE( InData%S )  ! S 
  Re_BufSz    = Re_BufSz    + SIZE( InData%M )  ! M 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IdNum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%FairConnect )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%AnchConnect )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%PropsIdNum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%N )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%UnstrLen )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%r) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%r))-1 ) =  PACK(InData%r ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%r)
  ENDIF
  IF ( ALLOCATED(InData%rd) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rd))-1 ) =  PACK(InData%rd ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rd)
  ENDIF
  IF ( ALLOCATED(InData%q) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%q))-1 ) =  PACK(InData%q ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%q)
  ENDIF
  IF ( ALLOCATED(InData%l) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%l))-1 ) =  PACK(InData%l ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%l)
  ENDIF
  IF ( ALLOCATED(InData%lstr) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%lstr))-1 ) =  PACK(InData%lstr ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%lstr)
  ENDIF
  IF ( ALLOCATED(InData%lstrd) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%lstrd))-1 ) =  PACK(InData%lstrd ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%lstrd)
  ENDIF
  IF ( ALLOCATED(InData%V) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%V))-1 ) =  PACK(InData%V ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%V)
  ENDIF
  IF ( ALLOCATED(InData%T) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%T))-1 ) =  PACK(InData%T ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%T)
  ENDIF
  IF ( ALLOCATED(InData%Td) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Td))-1 ) =  PACK(InData%Td ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Td)
  ENDIF
  IF ( ALLOCATED(InData%W) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%W))-1 ) =  PACK(InData%W ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%W)
  ENDIF
  IF ( ALLOCATED(InData%Dp) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Dp))-1 ) =  PACK(InData%Dp ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Dp)
  ENDIF
  IF ( ALLOCATED(InData%Dq) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Dq))-1 ) =  PACK(InData%Dq ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Dq)
  ENDIF
  IF ( ALLOCATED(InData%Ap) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ap))-1 ) =  PACK(InData%Ap ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Ap)
  ENDIF
  IF ( ALLOCATED(InData%Aq) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Aq))-1 ) =  PACK(InData%Aq ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Aq)
  ENDIF
  IF ( ALLOCATED(InData%B) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%B))-1 ) =  PACK(InData%B ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%B)
  ENDIF
  IF ( ALLOCATED(InData%F) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F))-1 ) =  PACK(InData%F ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F)
  ENDIF
  IF ( ALLOCATED(InData%S) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%S))-1 ) =  PACK(InData%S ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%S)
  ENDIF
  IF ( ALLOCATED(InData%M) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%M))-1 ) =  PACK(InData%M ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%M)
  ENDIF
 END SUBROUTINE MD_Packline

 SUBROUTINE MD_UnPackline( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(md_line), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%IdNum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%FairConnect = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%AnchConnect = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%PropsIdNum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%N = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnstrLen = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%r) ) THEN
  ALLOCATE(mask2(SIZE(OutData%r,1),SIZE(OutData%r,2))); mask2 = .TRUE.
    OutData%r = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%r))-1 ),mask2,OutData%r)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%r)
  ENDIF
  IF ( ALLOCATED(OutData%rd) ) THEN
  ALLOCATE(mask2(SIZE(OutData%rd,1),SIZE(OutData%rd,2))); mask2 = .TRUE.
    OutData%rd = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rd))-1 ),mask2,OutData%rd)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rd)
  ENDIF
  IF ( ALLOCATED(OutData%q) ) THEN
  ALLOCATE(mask2(SIZE(OutData%q,1),SIZE(OutData%q,2))); mask2 = .TRUE.
    OutData%q = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%q))-1 ),mask2,OutData%q)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%q)
  ENDIF
  IF ( ALLOCATED(OutData%l) ) THEN
  ALLOCATE(mask1(SIZE(OutData%l,1))); mask1 = .TRUE.
    OutData%l = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%l))-1 ),mask1,OutData%l)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%l)
  ENDIF
  IF ( ALLOCATED(OutData%lstr) ) THEN
  ALLOCATE(mask1(SIZE(OutData%lstr,1))); mask1 = .TRUE.
    OutData%lstr = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%lstr))-1 ),mask1,OutData%lstr)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%lstr)
  ENDIF
  IF ( ALLOCATED(OutData%lstrd) ) THEN
  ALLOCATE(mask1(SIZE(OutData%lstrd,1))); mask1 = .TRUE.
    OutData%lstrd = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%lstrd))-1 ),mask1,OutData%lstrd)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%lstrd)
  ENDIF
  IF ( ALLOCATED(OutData%V) ) THEN
  ALLOCATE(mask1(SIZE(OutData%V,1))); mask1 = .TRUE.
    OutData%V = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%V))-1 ),mask1,OutData%V)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%V)
  ENDIF
  IF ( ALLOCATED(OutData%T) ) THEN
  ALLOCATE(mask2(SIZE(OutData%T,1),SIZE(OutData%T,2))); mask2 = .TRUE.
    OutData%T = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%T))-1 ),mask2,OutData%T)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%T)
  ENDIF
  IF ( ALLOCATED(OutData%Td) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Td,1),SIZE(OutData%Td,2))); mask2 = .TRUE.
    OutData%Td = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Td))-1 ),mask2,OutData%Td)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Td)
  ENDIF
  IF ( ALLOCATED(OutData%W) ) THEN
  ALLOCATE(mask2(SIZE(OutData%W,1),SIZE(OutData%W,2))); mask2 = .TRUE.
    OutData%W = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%W))-1 ),mask2,OutData%W)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%W)
  ENDIF
  IF ( ALLOCATED(OutData%Dp) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Dp,1),SIZE(OutData%Dp,2))); mask2 = .TRUE.
    OutData%Dp = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Dp))-1 ),mask2,OutData%Dp)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Dp)
  ENDIF
  IF ( ALLOCATED(OutData%Dq) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Dq,1),SIZE(OutData%Dq,2))); mask2 = .TRUE.
    OutData%Dq = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Dq))-1 ),mask2,OutData%Dq)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Dq)
  ENDIF
  IF ( ALLOCATED(OutData%Ap) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Ap,1),SIZE(OutData%Ap,2))); mask2 = .TRUE.
    OutData%Ap = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ap))-1 ),mask2,OutData%Ap)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Ap)
  ENDIF
  IF ( ALLOCATED(OutData%Aq) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Aq,1),SIZE(OutData%Aq,2))); mask2 = .TRUE.
    OutData%Aq = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Aq))-1 ),mask2,OutData%Aq)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Aq)
  ENDIF
  IF ( ALLOCATED(OutData%B) ) THEN
  ALLOCATE(mask2(SIZE(OutData%B,1),SIZE(OutData%B,2))); mask2 = .TRUE.
    OutData%B = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%B))-1 ),mask2,OutData%B)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%B)
  ENDIF
  IF ( ALLOCATED(OutData%F) ) THEN
  ALLOCATE(mask2(SIZE(OutData%F,1),SIZE(OutData%F,2))); mask2 = .TRUE.
    OutData%F = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F))-1 ),mask2,OutData%F)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F)
  ENDIF
  IF ( ALLOCATED(OutData%S) ) THEN
  ALLOCATE(mask3(SIZE(OutData%S,1),SIZE(OutData%S,2),SIZE(OutData%S,3))); mask3 = .TRUE.
    OutData%S = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%S))-1 ),mask3,OutData%S)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%S)
  ENDIF
  IF ( ALLOCATED(OutData%M) ) THEN
  ALLOCATE(mask3(SIZE(OutData%M,1),SIZE(OutData%M,2),SIZE(OutData%M,3))); mask3 = .TRUE.
    OutData%M = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%M))-1 ),mask3,OutData%M)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%M)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackline

 SUBROUTINE MD_Copyoutparmtype( SrcoutparmtypeData, DstoutparmtypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(md_outparmtype), INTENT(INOUT) :: SrcoutparmtypeData
   TYPE(md_outparmtype), INTENT(INOUT) :: DstoutparmtypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstoutparmtypeData%Name = SrcoutparmtypeData%Name
   DstoutparmtypeData%Units = SrcoutparmtypeData%Units
   DstoutparmtypeData%QType = SrcoutparmtypeData%QType
   DstoutparmtypeData%OType = SrcoutparmtypeData%OType
   DstoutparmtypeData%NodeID = SrcoutparmtypeData%NodeID
   DstoutparmtypeData%ObjID = SrcoutparmtypeData%ObjID
 END SUBROUTINE MD_Copyoutparmtype

 SUBROUTINE MD_Destroyoutparmtype( outparmtypeData, ErrStat, ErrMsg )
  TYPE(md_outparmtype), INTENT(INOUT) :: outparmtypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MD_Destroyoutparmtype

 SUBROUTINE MD_Packoutparmtype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(md_outparmtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! QType
  Int_BufSz  = Int_BufSz  + 1  ! OType
  Int_BufSz  = Int_BufSz  + 1  ! NodeID
  Int_BufSz  = Int_BufSz  + 1  ! ObjID
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%QType )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OType )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NodeID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ObjID )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE MD_Packoutparmtype

 SUBROUTINE MD_UnPackoutparmtype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(md_outparmtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%QType = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OType = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NodeID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ObjID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackoutparmtype

 SUBROUTINE MD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
   TYPE(MD_initoutputtype), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitOutputData%progName = SrcInitOutputData%progName
   DstInitOutputData%version = SrcInitOutputData%version
   DstInitOutputData%compilingData = SrcInitOutputData%compilingData
IF (ALLOCATED(SrcInitOutputData%writeOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%writeOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%writeOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%writeOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%writeOutputHdr(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyInitOutput: Error allocating DstInitOutputData%writeOutputHdr.'
         RETURN
      END IF
   END IF
   DstInitOutputData%writeOutputHdr = SrcInitOutputData%writeOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%writeOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%writeOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%writeOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%writeOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%writeOutputUnt(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyInitOutput: Error allocating DstInitOutputData%writeOutputUnt.'
         RETURN
      END IF
   END IF
   DstInitOutputData%writeOutputUnt = SrcInitOutputData%writeOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE MD_CopyInitOutput

 SUBROUTINE MD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(MD_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%writeOutputHdr)) THEN
   DEALLOCATE(InitOutputData%writeOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%writeOutputUnt)) THEN
   DEALLOCATE(InitOutputData%writeOutputUnt)
ENDIF
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
 END SUBROUTINE MD_DestroyInitOutput

 SUBROUTINE MD_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
 END SUBROUTINE MD_PackInitOutput

 SUBROUTINE MD_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackInitOutput

 SUBROUTINE MD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_continuousstatetype), INTENT(INOUT) :: SrcContStateData
   TYPE(MD_continuousstatetype), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%states)) THEN
   i1_l = LBOUND(SrcContStateData%states,1)
   i1_u = UBOUND(SrcContStateData%states,1)
   IF (.NOT. ALLOCATED(DstContStateData%states)) THEN 
      ALLOCATE(DstContStateData%states(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyContState: Error allocating DstContStateData%states.'
         RETURN
      END IF
   END IF
   DstContStateData%states = SrcContStateData%states
ENDIF
 END SUBROUTINE MD_CopyContState

 SUBROUTINE MD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(MD_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ContStateData%states)) THEN
   DEALLOCATE(ContStateData%states)
ENDIF
 END SUBROUTINE MD_DestroyContState

 SUBROUTINE MD_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%states )  ! states 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%states) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%states))-1 ) =  PACK(InData%states ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%states)
  ENDIF
 END SUBROUTINE MD_PackContState

 SUBROUTINE MD_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%states) ) THEN
  ALLOCATE(mask1(SIZE(OutData%states,1))); mask1 = .TRUE.
    OutData%states = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%states))-1 ),mask1,OutData%states)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%states)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackContState

 SUBROUTINE MD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
   TYPE(MD_discretestatetype), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%dummy = SrcDiscStateData%dummy
 END SUBROUTINE MD_CopyDiscState

 SUBROUTINE MD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(MD_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MD_DestroyDiscState

 SUBROUTINE MD_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! dummy
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dummy )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE MD_PackDiscState

 SUBROUTINE MD_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dummy = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackDiscState

 SUBROUTINE MD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
   TYPE(MD_otherstatetype), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%LineTypeList)) THEN
   i1_l = LBOUND(SrcOtherStateData%LineTypeList,1)
   i1_u = UBOUND(SrcOtherStateData%LineTypeList,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%LineTypeList)) THEN 
      ALLOCATE(DstOtherStateData%LineTypeList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyOtherState: Error allocating DstOtherStateData%LineTypeList.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcOtherStateData%LineTypeList,1), UBOUND(SrcOtherStateData%LineTypeList,1)
      CALL MD_Copylineprop( SrcOtherStateData%LineTypeList(i1), DstOtherStateData%LineTypeList(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
IF (ALLOCATED(SrcOtherStateData%ConnectList)) THEN
   i1_l = LBOUND(SrcOtherStateData%ConnectList,1)
   i1_u = UBOUND(SrcOtherStateData%ConnectList,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%ConnectList)) THEN 
      ALLOCATE(DstOtherStateData%ConnectList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyOtherState: Error allocating DstOtherStateData%ConnectList.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcOtherStateData%ConnectList,1), UBOUND(SrcOtherStateData%ConnectList,1)
      CALL MD_Copyconnect( SrcOtherStateData%ConnectList(i1), DstOtherStateData%ConnectList(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
IF (ALLOCATED(SrcOtherStateData%LineList)) THEN
   i1_l = LBOUND(SrcOtherStateData%LineList,1)
   i1_u = UBOUND(SrcOtherStateData%LineList,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%LineList)) THEN 
      ALLOCATE(DstOtherStateData%LineList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyOtherState: Error allocating DstOtherStateData%LineList.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcOtherStateData%LineList,1), UBOUND(SrcOtherStateData%LineList,1)
      CALL MD_Copyline( SrcOtherStateData%LineList(i1), DstOtherStateData%LineList(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
IF (ALLOCATED(SrcOtherStateData%FairIdList)) THEN
   i1_l = LBOUND(SrcOtherStateData%FairIdList,1)
   i1_u = UBOUND(SrcOtherStateData%FairIdList,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%FairIdList)) THEN 
      ALLOCATE(DstOtherStateData%FairIdList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyOtherState: Error allocating DstOtherStateData%FairIdList.'
         RETURN
      END IF
   END IF
   DstOtherStateData%FairIdList = SrcOtherStateData%FairIdList
ENDIF
IF (ALLOCATED(SrcOtherStateData%LineStateIndList)) THEN
   i1_l = LBOUND(SrcOtherStateData%LineStateIndList,1)
   i1_u = UBOUND(SrcOtherStateData%LineStateIndList,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%LineStateIndList)) THEN 
      ALLOCATE(DstOtherStateData%LineStateIndList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyOtherState: Error allocating DstOtherStateData%LineStateIndList.'
         RETURN
      END IF
   END IF
   DstOtherStateData%LineStateIndList = SrcOtherStateData%LineStateIndList
ENDIF
IF (ALLOCATED(SrcOtherStateData%F)) THEN
   i1_l = LBOUND(SrcOtherStateData%F,1)
   i1_u = UBOUND(SrcOtherStateData%F,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%F)) THEN 
      ALLOCATE(DstOtherStateData%F(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyOtherState: Error allocating DstOtherStateData%F.'
         RETURN
      END IF
   END IF
   DstOtherStateData%F = SrcOtherStateData%F
ENDIF
 END SUBROUTINE MD_CopyOtherState

 SUBROUTINE MD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(MD_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%LineTypeList)) THEN
DO i1 = LBOUND(OtherStateData%LineTypeList,1), UBOUND(OtherStateData%LineTypeList,1)
  CALL MD_Destroylineprop( OtherStateData%LineTypeList(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(OtherStateData%LineTypeList)
ENDIF
IF (ALLOCATED(OtherStateData%ConnectList)) THEN
DO i1 = LBOUND(OtherStateData%ConnectList,1), UBOUND(OtherStateData%ConnectList,1)
  CALL MD_Destroyconnect( OtherStateData%ConnectList(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(OtherStateData%ConnectList)
ENDIF
IF (ALLOCATED(OtherStateData%LineList)) THEN
DO i1 = LBOUND(OtherStateData%LineList,1), UBOUND(OtherStateData%LineList,1)
  CALL MD_Destroyline( OtherStateData%LineList(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(OtherStateData%LineList)
ENDIF
IF (ALLOCATED(OtherStateData%FairIdList)) THEN
   DEALLOCATE(OtherStateData%FairIdList)
ENDIF
IF (ALLOCATED(OtherStateData%LineStateIndList)) THEN
   DEALLOCATE(OtherStateData%LineStateIndList)
ENDIF
IF (ALLOCATED(OtherStateData%F)) THEN
   DEALLOCATE(OtherStateData%F)
ENDIF
 END SUBROUTINE MD_DestroyOtherState

 SUBROUTINE MD_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_LineTypeList_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LineTypeList_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LineTypeList_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_ConnectList_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_ConnectList_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_ConnectList_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LineList_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LineList_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LineList_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(InData%LineTypeList,1), UBOUND(InData%LineTypeList,1)
  CALL MD_Packlineprop( Re_LineTypeList_Buf, Db_LineTypeList_Buf, Int_LineTypeList_Buf, InData%LineTypeList(i1), ErrStat, ErrMsg, .TRUE. ) ! LineTypeList 
  IF(ALLOCATED(Re_LineTypeList_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LineTypeList_Buf  ) ! LineTypeList
  IF(ALLOCATED(Db_LineTypeList_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LineTypeList_Buf  ) ! LineTypeList
  IF(ALLOCATED(Int_LineTypeList_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LineTypeList_Buf ) ! LineTypeList
  IF(ALLOCATED(Re_LineTypeList_Buf))  DEALLOCATE(Re_LineTypeList_Buf)
  IF(ALLOCATED(Db_LineTypeList_Buf))  DEALLOCATE(Db_LineTypeList_Buf)
  IF(ALLOCATED(Int_LineTypeList_Buf)) DEALLOCATE(Int_LineTypeList_Buf)
ENDDO
DO i1 = LBOUND(InData%ConnectList,1), UBOUND(InData%ConnectList,1)
  CALL MD_Packconnect( Re_ConnectList_Buf, Db_ConnectList_Buf, Int_ConnectList_Buf, InData%ConnectList(i1), ErrStat, ErrMsg, .TRUE. ) ! ConnectList 
  IF(ALLOCATED(Re_ConnectList_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_ConnectList_Buf  ) ! ConnectList
  IF(ALLOCATED(Db_ConnectList_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_ConnectList_Buf  ) ! ConnectList
  IF(ALLOCATED(Int_ConnectList_Buf))Int_BufSz = Int_BufSz + SIZE( Int_ConnectList_Buf ) ! ConnectList
  IF(ALLOCATED(Re_ConnectList_Buf))  DEALLOCATE(Re_ConnectList_Buf)
  IF(ALLOCATED(Db_ConnectList_Buf))  DEALLOCATE(Db_ConnectList_Buf)
  IF(ALLOCATED(Int_ConnectList_Buf)) DEALLOCATE(Int_ConnectList_Buf)
ENDDO
DO i1 = LBOUND(InData%LineList,1), UBOUND(InData%LineList,1)
  CALL MD_Packline( Re_LineList_Buf, Db_LineList_Buf, Int_LineList_Buf, InData%LineList(i1), ErrStat, ErrMsg, .TRUE. ) ! LineList 
  IF(ALLOCATED(Re_LineList_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LineList_Buf  ) ! LineList
  IF(ALLOCATED(Db_LineList_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LineList_Buf  ) ! LineList
  IF(ALLOCATED(Int_LineList_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LineList_Buf ) ! LineList
  IF(ALLOCATED(Re_LineList_Buf))  DEALLOCATE(Re_LineList_Buf)
  IF(ALLOCATED(Db_LineList_Buf))  DEALLOCATE(Db_LineList_Buf)
  IF(ALLOCATED(Int_LineList_Buf)) DEALLOCATE(Int_LineList_Buf)
ENDDO
  Int_BufSz   = Int_BufSz   + SIZE( InData%FairIdList )  ! FairIdList 
  Int_BufSz   = Int_BufSz   + SIZE( InData%LineStateIndList )  ! LineStateIndList 
  Re_BufSz    = Re_BufSz    + SIZE( InData%F )  ! F 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
DO i1 = LBOUND(InData%LineTypeList,1), UBOUND(InData%LineTypeList,1)
  CALL MD_Packlineprop( Re_LineTypeList_Buf, Db_LineTypeList_Buf, Int_LineTypeList_Buf, InData%LineTypeList(i1), ErrStat, ErrMsg, OnlySize ) ! LineTypeList 
  IF(ALLOCATED(Re_LineTypeList_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineTypeList_Buf)-1 ) = Re_LineTypeList_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LineTypeList_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineTypeList_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineTypeList_Buf)-1 ) = Db_LineTypeList_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LineTypeList_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineTypeList_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineTypeList_Buf)-1 ) = Int_LineTypeList_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LineTypeList_Buf)
  ENDIF
  IF( ALLOCATED(Re_LineTypeList_Buf) )  DEALLOCATE(Re_LineTypeList_Buf)
  IF( ALLOCATED(Db_LineTypeList_Buf) )  DEALLOCATE(Db_LineTypeList_Buf)
  IF( ALLOCATED(Int_LineTypeList_Buf) ) DEALLOCATE(Int_LineTypeList_Buf)
ENDDO
DO i1 = LBOUND(InData%ConnectList,1), UBOUND(InData%ConnectList,1)
  CALL MD_Packconnect( Re_ConnectList_Buf, Db_ConnectList_Buf, Int_ConnectList_Buf, InData%ConnectList(i1), ErrStat, ErrMsg, OnlySize ) ! ConnectList 
  IF(ALLOCATED(Re_ConnectList_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ConnectList_Buf)-1 ) = Re_ConnectList_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_ConnectList_Buf)
  ENDIF
  IF(ALLOCATED(Db_ConnectList_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ConnectList_Buf)-1 ) = Db_ConnectList_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_ConnectList_Buf)
  ENDIF
  IF(ALLOCATED(Int_ConnectList_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ConnectList_Buf)-1 ) = Int_ConnectList_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_ConnectList_Buf)
  ENDIF
  IF( ALLOCATED(Re_ConnectList_Buf) )  DEALLOCATE(Re_ConnectList_Buf)
  IF( ALLOCATED(Db_ConnectList_Buf) )  DEALLOCATE(Db_ConnectList_Buf)
  IF( ALLOCATED(Int_ConnectList_Buf) ) DEALLOCATE(Int_ConnectList_Buf)
ENDDO
DO i1 = LBOUND(InData%LineList,1), UBOUND(InData%LineList,1)
  CALL MD_Packline( Re_LineList_Buf, Db_LineList_Buf, Int_LineList_Buf, InData%LineList(i1), ErrStat, ErrMsg, OnlySize ) ! LineList 
  IF(ALLOCATED(Re_LineList_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineList_Buf)-1 ) = Re_LineList_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LineList_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineList_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineList_Buf)-1 ) = Db_LineList_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LineList_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineList_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineList_Buf)-1 ) = Int_LineList_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LineList_Buf)
  ENDIF
  IF( ALLOCATED(Re_LineList_Buf) )  DEALLOCATE(Re_LineList_Buf)
  IF( ALLOCATED(Db_LineList_Buf) )  DEALLOCATE(Db_LineList_Buf)
  IF( ALLOCATED(Int_LineList_Buf) ) DEALLOCATE(Int_LineList_Buf)
ENDDO
  IF ( ALLOCATED(InData%FairIdList) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%FairIdList))-1 ) = PACK(InData%FairIdList ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%FairIdList)
  ENDIF
  IF ( ALLOCATED(InData%LineStateIndList) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%LineStateIndList))-1 ) = PACK(InData%LineStateIndList ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%LineStateIndList)
  ENDIF
  IF ( ALLOCATED(InData%F) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F))-1 ) =  PACK(InData%F ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F)
  ENDIF
 END SUBROUTINE MD_PackOtherState

 SUBROUTINE MD_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_LineTypeList_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LineTypeList_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LineTypeList_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_ConnectList_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_ConnectList_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_ConnectList_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LineList_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LineList_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LineList_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(OutData%LineTypeList,1), UBOUND(OutData%LineTypeList,1)
 ! first call MD_Packlineprop to get correctly sized buffers for unpacking
  CALL MD_Packlineprop( Re_LineTypeList_Buf, Db_LineTypeList_Buf, Int_LineTypeList_Buf, OutData%LineTypeList(i1), ErrStat, ErrMsg, .TRUE. ) ! LineTypeList 
  IF(ALLOCATED(Re_LineTypeList_Buf)) THEN
    Re_LineTypeList_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineTypeList_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LineTypeList_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineTypeList_Buf)) THEN
    Db_LineTypeList_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineTypeList_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LineTypeList_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineTypeList_Buf)) THEN
    Int_LineTypeList_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineTypeList_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LineTypeList_Buf)
  ENDIF
  CALL MD_UnPacklineprop( Re_LineTypeList_Buf, Db_LineTypeList_Buf, Int_LineTypeList_Buf, OutData%LineTypeList(i1), ErrStat, ErrMsg ) ! LineTypeList 
ENDDO
DO i1 = LBOUND(OutData%ConnectList,1), UBOUND(OutData%ConnectList,1)
 ! first call MD_Packconnect to get correctly sized buffers for unpacking
  CALL MD_Packconnect( Re_ConnectList_Buf, Db_ConnectList_Buf, Int_ConnectList_Buf, OutData%ConnectList(i1), ErrStat, ErrMsg, .TRUE. ) ! ConnectList 
  IF(ALLOCATED(Re_ConnectList_Buf)) THEN
    Re_ConnectList_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ConnectList_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_ConnectList_Buf)
  ENDIF
  IF(ALLOCATED(Db_ConnectList_Buf)) THEN
    Db_ConnectList_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ConnectList_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_ConnectList_Buf)
  ENDIF
  IF(ALLOCATED(Int_ConnectList_Buf)) THEN
    Int_ConnectList_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ConnectList_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_ConnectList_Buf)
  ENDIF
  CALL MD_UnPackconnect( Re_ConnectList_Buf, Db_ConnectList_Buf, Int_ConnectList_Buf, OutData%ConnectList(i1), ErrStat, ErrMsg ) ! ConnectList 
ENDDO
DO i1 = LBOUND(OutData%LineList,1), UBOUND(OutData%LineList,1)
 ! first call MD_Packline to get correctly sized buffers for unpacking
  CALL MD_Packline( Re_LineList_Buf, Db_LineList_Buf, Int_LineList_Buf, OutData%LineList(i1), ErrStat, ErrMsg, .TRUE. ) ! LineList 
  IF(ALLOCATED(Re_LineList_Buf)) THEN
    Re_LineList_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineList_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LineList_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineList_Buf)) THEN
    Db_LineList_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineList_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LineList_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineList_Buf)) THEN
    Int_LineList_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineList_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LineList_Buf)
  ENDIF
  CALL MD_UnPackline( Re_LineList_Buf, Db_LineList_Buf, Int_LineList_Buf, OutData%LineList(i1), ErrStat, ErrMsg ) ! LineList 
ENDDO
  IF ( ALLOCATED(OutData%FairIdList) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FairIdList,1))); mask1 = .TRUE.
    OutData%FairIdList = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%FairIdList))-1 ),mask1,OutData%FairIdList)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%FairIdList)
  ENDIF
  IF ( ALLOCATED(OutData%LineStateIndList) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LineStateIndList,1))); mask1 = .TRUE.
    OutData%LineStateIndList = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%LineStateIndList))-1 ),mask1,OutData%LineStateIndList)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%LineStateIndList)
  ENDIF
  IF ( ALLOCATED(OutData%F) ) THEN
  ALLOCATE(mask1(SIZE(OutData%F,1))); mask1 = .TRUE.
    OutData%F = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F))-1 ),mask1,OutData%F)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackOtherState

 SUBROUTINE MD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
   TYPE(MD_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcConstrStateData%dummy)) THEN
   i1_l = LBOUND(SrcConstrStateData%dummy,1)
   i1_u = UBOUND(SrcConstrStateData%dummy,1)
   IF (.NOT. ALLOCATED(DstConstrStateData%dummy)) THEN 
      ALLOCATE(DstConstrStateData%dummy(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyConstrState: Error allocating DstConstrStateData%dummy.'
         RETURN
      END IF
   END IF
   DstConstrStateData%dummy = SrcConstrStateData%dummy
ENDIF
 END SUBROUTINE MD_CopyConstrState

 SUBROUTINE MD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(MD_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ConstrStateData%dummy)) THEN
   DEALLOCATE(ConstrStateData%dummy)
ENDIF
 END SUBROUTINE MD_DestroyConstrState

 SUBROUTINE MD_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%dummy )  ! dummy 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%dummy) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%dummy))-1 ) =  PACK(InData%dummy ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%dummy)
  ENDIF
 END SUBROUTINE MD_PackConstrState

 SUBROUTINE MD_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%dummy) ) THEN
  ALLOCATE(mask1(SIZE(OutData%dummy,1))); mask1 = .TRUE.
    OutData%dummy = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%dummy))-1 ),mask1,OutData%dummy)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%dummy)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackConstrState

 SUBROUTINE MD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_parametertype), INTENT(INOUT) :: SrcParamData
   TYPE(MD_parametertype), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%NTypes = SrcParamData%NTypes
   DstParamData%NConnects = SrcParamData%NConnects
   DstParamData%NLines = SrcParamData%NLines
   DstParamData%NFairs = SrcParamData%NFairs
   DstParamData%g = SrcParamData%g
   DstParamData%rhoW = SrcParamData%rhoW
   DstParamData%WtrDpth = SrcParamData%WtrDpth
   DstParamData%kBot = SrcParamData%kBot
   DstParamData%cBot = SrcParamData%cBot
   DstParamData%dt = SrcParamData%dt
   DstParamData%dtCoupling = SrcParamData%dtCoupling
   DstParamData%Ndt = SrcParamData%Ndt
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%RootName = SrcParamData%RootName
IF (ALLOCATED(SrcParamData%OutParam)) THEN
   i1_l = LBOUND(SrcParamData%OutParam,1)
   i1_u = UBOUND(SrcParamData%OutParam,1)
   IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
      ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyParam: Error allocating DstParamData%OutParam.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL MD_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
   DstParamData%Delim = SrcParamData%Delim
 END SUBROUTINE MD_CopyParam

 SUBROUTINE MD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(MD_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL MD_Destroyoutparmtype( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%OutParam)
ENDIF
 END SUBROUTINE MD_DestroyParam

 SUBROUTINE MD_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_OutParam_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! NTypes
  Int_BufSz  = Int_BufSz  + 1  ! NConnects
  Int_BufSz  = Int_BufSz  + 1  ! NLines
  Int_BufSz  = Int_BufSz  + 1  ! NFairs
  Re_BufSz   = Re_BufSz   + 1  ! g
  Re_BufSz   = Re_BufSz   + 1  ! rhoW
  Re_BufSz   = Re_BufSz   + 1  ! WtrDpth
  Re_BufSz   = Re_BufSz   + 1  ! kBot
  Re_BufSz   = Re_BufSz   + 1  ! cBot
  Re_BufSz   = Re_BufSz   + 1  ! dt
  Re_BufSz   = Re_BufSz   + 1  ! dtCoupling
  Int_BufSz  = Int_BufSz  + 1  ! Ndt
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL MD_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Db_OutParam_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Int_OutParam_Buf))Int_BufSz = Int_BufSz + SIZE( Int_OutParam_Buf ) ! OutParam
  IF(ALLOCATED(Re_OutParam_Buf))  DEALLOCATE(Re_OutParam_Buf)
  IF(ALLOCATED(Db_OutParam_Buf))  DEALLOCATE(Db_OutParam_Buf)
  IF(ALLOCATED(Int_OutParam_Buf)) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NTypes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NConnects )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NLines )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NFairs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%g )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%rhoW )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDpth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%kBot )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%cBot )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dtCoupling )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Ndt )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL MD_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, OnlySize ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 ) = Re_OutParam_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 ) = Db_OutParam_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 ) = Int_OutParam_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  IF( ALLOCATED(Re_OutParam_Buf) )  DEALLOCATE(Re_OutParam_Buf)
  IF( ALLOCATED(Db_OutParam_Buf) )  DEALLOCATE(Db_OutParam_Buf)
  IF( ALLOCATED(Int_OutParam_Buf) ) DEALLOCATE(Int_OutParam_Buf)
ENDDO
 END SUBROUTINE MD_PackParam

 SUBROUTINE MD_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_OutParam_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%NTypes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NConnects = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NLines = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NFairs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%g = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%rhoW = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDpth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%kBot = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%cBot = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%dt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%dtCoupling = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ndt = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
 ! first call MD_Packoutparmtype to get correctly sized buffers for unpacking
  CALL MD_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    Re_OutParam_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    Db_OutParam_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    Int_OutParam_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  CALL MD_UnPackoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg ) ! OutParam 
ENDDO
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackParam

 SUBROUTINE MD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_inputtype), INTENT(INOUT) :: SrcInputData
   TYPE(MD_inputtype), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%x)) THEN
   i1_l = LBOUND(SrcInputData%x,1)
   i1_u = UBOUND(SrcInputData%x,1)
   IF (.NOT. ALLOCATED(DstInputData%x)) THEN 
      ALLOCATE(DstInputData%x(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyInput: Error allocating DstInputData%x.'
         RETURN
      END IF
   END IF
   DstInputData%x = SrcInputData%x
ENDIF
IF (ALLOCATED(SrcInputData%y)) THEN
   i1_l = LBOUND(SrcInputData%y,1)
   i1_u = UBOUND(SrcInputData%y,1)
   IF (.NOT. ALLOCATED(DstInputData%y)) THEN 
      ALLOCATE(DstInputData%y(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyInput: Error allocating DstInputData%y.'
         RETURN
      END IF
   END IF
   DstInputData%y = SrcInputData%y
ENDIF
IF (ALLOCATED(SrcInputData%z)) THEN
   i1_l = LBOUND(SrcInputData%z,1)
   i1_u = UBOUND(SrcInputData%z,1)
   IF (.NOT. ALLOCATED(DstInputData%z)) THEN 
      ALLOCATE(DstInputData%z(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyInput: Error allocating DstInputData%z.'
         RETURN
      END IF
   END IF
   DstInputData%z = SrcInputData%z
ENDIF
     CALL MeshCopy( SrcInputData%PtFairleadDisplacement, DstInputData%PtFairleadDisplacement, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE MD_CopyInput

 SUBROUTINE MD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(MD_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputData%x)) THEN
   DEALLOCATE(InputData%x)
ENDIF
IF (ALLOCATED(InputData%y)) THEN
   DEALLOCATE(InputData%y)
ENDIF
IF (ALLOCATED(InputData%z)) THEN
   DEALLOCATE(InputData%z)
ENDIF
  CALL MeshDestroy( InputData%PtFairleadDisplacement, ErrStat, ErrMsg )
 END SUBROUTINE MD_DestroyInput

 SUBROUTINE MD_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%x )  ! x 
  Re_BufSz    = Re_BufSz    + SIZE( InData%y )  ! y 
  Re_BufSz    = Re_BufSz    + SIZE( InData%z )  ! z 
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadDisplacement_Buf ) ! PtFairleadDisplacement
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf))  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf))  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%x) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%x))-1 ) =  PACK(InData%x ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%x)
  ENDIF
  IF ( ALLOCATED(InData%y) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%y))-1 ) =  PACK(InData%y ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%y)
  ENDIF
  IF ( ALLOCATED(InData%z) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%z))-1 ) =  PACK(InData%z ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%z)
  ENDIF
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 ) = Re_PtFairleadDisplacement_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 ) = Db_PtFairleadDisplacement_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 ) = Int_PtFairleadDisplacement_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
 END SUBROUTINE MD_PackInput

 SUBROUTINE MD_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%x) ) THEN
  ALLOCATE(mask1(SIZE(OutData%x,1))); mask1 = .TRUE.
    OutData%x = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%x))-1 ),mask1,OutData%x)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%x)
  ENDIF
  IF ( ALLOCATED(OutData%y) ) THEN
  ALLOCATE(mask1(SIZE(OutData%y,1))); mask1 = .TRUE.
    OutData%y = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%y))-1 ),mask1,OutData%y)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%y)
  ENDIF
  IF ( ALLOCATED(OutData%z) ) THEN
  ALLOCATE(mask1(SIZE(OutData%z,1))); mask1 = .TRUE.
    OutData%z = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%z))-1 ),mask1,OutData%z)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%z)
  ENDIF
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    Re_PtFairleadDisplacement_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    Db_PtFairleadDisplacement_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    Int_PtFairleadDisplacement_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg ) ! PtFairleadDisplacement 
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackInput

 SUBROUTINE MD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_outputtype), INTENT(INOUT) :: SrcOutputData
   TYPE(MD_outputtype), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%Fx)) THEN
   i1_l = LBOUND(SrcOutputData%Fx,1)
   i1_u = UBOUND(SrcOutputData%Fx,1)
   IF (.NOT. ALLOCATED(DstOutputData%Fx)) THEN 
      ALLOCATE(DstOutputData%Fx(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyOutput: Error allocating DstOutputData%Fx.'
         RETURN
      END IF
   END IF
   DstOutputData%Fx = SrcOutputData%Fx
ENDIF
IF (ALLOCATED(SrcOutputData%Fy)) THEN
   i1_l = LBOUND(SrcOutputData%Fy,1)
   i1_u = UBOUND(SrcOutputData%Fy,1)
   IF (.NOT. ALLOCATED(DstOutputData%Fy)) THEN 
      ALLOCATE(DstOutputData%Fy(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyOutput: Error allocating DstOutputData%Fy.'
         RETURN
      END IF
   END IF
   DstOutputData%Fy = SrcOutputData%Fy
ENDIF
IF (ALLOCATED(SrcOutputData%Fz)) THEN
   i1_l = LBOUND(SrcOutputData%Fz,1)
   i1_u = UBOUND(SrcOutputData%Fz,1)
   IF (.NOT. ALLOCATED(DstOutputData%Fz)) THEN 
      ALLOCATE(DstOutputData%Fz(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyOutput: Error allocating DstOutputData%Fz.'
         RETURN
      END IF
   END IF
   DstOutputData%Fz = SrcOutputData%Fz
ENDIF
     CALL MeshCopy( SrcOutputData%PtFairleadLoad, DstOutputData%PtFairleadLoad, CtrlCode, ErrStat, ErrMsg )
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MD_CopyOutput: Error allocating DstOutputData%WriteOutput.'
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE MD_CopyOutput

 SUBROUTINE MD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(MD_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%Fx)) THEN
   DEALLOCATE(OutputData%Fx)
ENDIF
IF (ALLOCATED(OutputData%Fy)) THEN
   DEALLOCATE(OutputData%Fy)
ENDIF
IF (ALLOCATED(OutputData%Fz)) THEN
   DEALLOCATE(OutputData%Fz)
ENDIF
  CALL MeshDestroy( OutputData%PtFairleadLoad, ErrStat, ErrMsg )
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE MD_DestroyOutput

 SUBROUTINE MD_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%Fx )  ! Fx 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Fy )  ! Fy 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Fz )  ! Fz 
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Int_PtFairleadLoad_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadLoad_Buf ) ! PtFairleadLoad
  IF(ALLOCATED(Re_PtFairleadLoad_Buf))  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF(ALLOCATED(Db_PtFairleadLoad_Buf))  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) DEALLOCATE(Int_PtFairleadLoad_Buf)
  Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%Fx) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fx))-1 ) =  PACK(InData%Fx ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Fx)
  ENDIF
  IF ( ALLOCATED(InData%Fy) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fy))-1 ) =  PACK(InData%Fy ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Fy)
  ENDIF
  IF ( ALLOCATED(InData%Fz) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fz))-1 ) =  PACK(InData%Fz ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Fz)
  ENDIF
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 ) = Re_PtFairleadLoad_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 ) = Db_PtFairleadLoad_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 ) = Int_PtFairleadLoad_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE MD_PackOutput

 SUBROUTINE MD_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%Fx) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fx,1))); mask1 = .TRUE.
    OutData%Fx = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fx))-1 ),mask1,OutData%Fx)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Fx)
  ENDIF
  IF ( ALLOCATED(OutData%Fy) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fy,1))); mask1 = .TRUE.
    OutData%Fy = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fy))-1 ),mask1,OutData%Fy)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Fy)
  ENDIF
  IF ( ALLOCATED(OutData%Fz) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fz,1))); mask1 = .TRUE.
    OutData%Fz = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fz))-1 ),mask1,OutData%Fz)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Fz)
  ENDIF
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    Re_PtFairleadLoad_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    Db_PtFairleadLoad_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    Int_PtFairleadLoad_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg ) ! PtFairleadLoad 
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1))); mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackOutput


 SUBROUTINE MD_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MD_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(MD_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in MD_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%x) .AND. ALLOCATED(u(1)%x)) THEN
  u_out%x = u(1)%x
END IF ! check if allocated
IF (ALLOCATED(u_out%y) .AND. ALLOCATED(u(1)%y)) THEN
  u_out%y = u(1)%y
END IF ! check if allocated
IF (ALLOCATED(u_out%z) .AND. ALLOCATED(u(1)%z)) THEN
  u_out%z = u(1)%z
END IF ! check if allocated
  CALL MeshCopy(u(1)%PtFairleadDisplacement, u_out%PtFairleadDisplacement, MESH_UPDATECOPY, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%x) .AND. ALLOCATED(u(1)%x)) THEN
  ALLOCATE(b1(SIZE(u_out%x,1)))
  ALLOCATE(c1(SIZE(u_out%x,1)))
  b1 = -(u(1)%x - u(2)%x)/t(2)
  u_out%x = u(1)%x + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%y) .AND. ALLOCATED(u(1)%y)) THEN
  ALLOCATE(b1(SIZE(u_out%y,1)))
  ALLOCATE(c1(SIZE(u_out%y,1)))
  b1 = -(u(1)%y - u(2)%y)/t(2)
  u_out%y = u(1)%y + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%z) .AND. ALLOCATED(u(1)%z)) THEN
  ALLOCATE(b1(SIZE(u_out%z,1)))
  ALLOCATE(c1(SIZE(u_out%z,1)))
  b1 = -(u(1)%z - u(2)%z)/t(2)
  u_out%z = u(1)%z + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp1(u(1)%PtFairleadDisplacement, u(2)%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%x) .AND. ALLOCATED(u(1)%x)) THEN
  ALLOCATE(b1(SIZE(u_out%x,1)))
  ALLOCATE(c1(SIZE(u_out%x,1)))
  b1 = (t(3)**2*(u(1)%x - u(2)%x) + t(2)**2*(-u(1)%x + u(3)%x))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%x + t(3)*u(2)%x - t(2)*u(3)%x ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%x = u(1)%x + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%y) .AND. ALLOCATED(u(1)%y)) THEN
  ALLOCATE(b1(SIZE(u_out%y,1)))
  ALLOCATE(c1(SIZE(u_out%y,1)))
  b1 = (t(3)**2*(u(1)%y - u(2)%y) + t(2)**2*(-u(1)%y + u(3)%y))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%y + t(3)*u(2)%y - t(2)*u(3)%y ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%y = u(1)%y + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%z) .AND. ALLOCATED(u(1)%z)) THEN
  ALLOCATE(b1(SIZE(u_out%z,1)))
  ALLOCATE(c1(SIZE(u_out%z,1)))
  b1 = (t(3)**2*(u(1)%z - u(2)%z) + t(2)**2*(-u(1)%z + u(3)%z))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%z + t(3)*u(2)%z - t(2)*u(3)%z ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%z = u(1)%z + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp2(u(1)%PtFairleadDisplacement, u(2)%PtFairleadDisplacement, u(3)%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat, ErrMsg )
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in MD_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE MD_Input_ExtrapInterp


 SUBROUTINE MD_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MD_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(MD_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in MD_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%Fx) .AND. ALLOCATED(u(1)%Fx)) THEN
  u_out%Fx = u(1)%Fx
END IF ! check if allocated
IF (ALLOCATED(u_out%Fy) .AND. ALLOCATED(u(1)%Fy)) THEN
  u_out%Fy = u(1)%Fy
END IF ! check if allocated
IF (ALLOCATED(u_out%Fz) .AND. ALLOCATED(u(1)%Fz)) THEN
  u_out%Fz = u(1)%Fz
END IF ! check if allocated
  CALL MeshCopy(u(1)%PtFairleadLoad, u_out%PtFairleadLoad, MESH_UPDATECOPY, ErrStat, ErrMsg )
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%Fx) .AND. ALLOCATED(u(1)%Fx)) THEN
  ALLOCATE(b1(SIZE(u_out%Fx,1)))
  ALLOCATE(c1(SIZE(u_out%Fx,1)))
  b1 = -(u(1)%Fx - u(2)%Fx)/t(2)
  u_out%Fx = u(1)%Fx + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Fy) .AND. ALLOCATED(u(1)%Fy)) THEN
  ALLOCATE(b1(SIZE(u_out%Fy,1)))
  ALLOCATE(c1(SIZE(u_out%Fy,1)))
  b1 = -(u(1)%Fy - u(2)%Fy)/t(2)
  u_out%Fy = u(1)%Fy + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Fz) .AND. ALLOCATED(u(1)%Fz)) THEN
  ALLOCATE(b1(SIZE(u_out%Fz,1)))
  ALLOCATE(c1(SIZE(u_out%Fz,1)))
  b1 = -(u(1)%Fz - u(2)%Fz)/t(2)
  u_out%Fz = u(1)%Fz + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp1(u(1)%PtFairleadLoad, u(2)%PtFairleadLoad, tin, u_out%PtFairleadLoad, tin_out, ErrStat, ErrMsg )
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%Fx) .AND. ALLOCATED(u(1)%Fx)) THEN
  ALLOCATE(b1(SIZE(u_out%Fx,1)))
  ALLOCATE(c1(SIZE(u_out%Fx,1)))
  b1 = (t(3)**2*(u(1)%Fx - u(2)%Fx) + t(2)**2*(-u(1)%Fx + u(3)%Fx))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Fx + t(3)*u(2)%Fx - t(2)*u(3)%Fx ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Fx = u(1)%Fx + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Fy) .AND. ALLOCATED(u(1)%Fy)) THEN
  ALLOCATE(b1(SIZE(u_out%Fy,1)))
  ALLOCATE(c1(SIZE(u_out%Fy,1)))
  b1 = (t(3)**2*(u(1)%Fy - u(2)%Fy) + t(2)**2*(-u(1)%Fy + u(3)%Fy))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Fy + t(3)*u(2)%Fy - t(2)*u(3)%Fy ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Fy = u(1)%Fy + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Fz) .AND. ALLOCATED(u(1)%Fz)) THEN
  ALLOCATE(b1(SIZE(u_out%Fz,1)))
  ALLOCATE(c1(SIZE(u_out%Fz,1)))
  b1 = (t(3)**2*(u(1)%Fz - u(2)%Fz) + t(2)**2*(-u(1)%Fz + u(3)%Fz))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Fz + t(3)*u(2)%Fz - t(2)*u(3)%Fz ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Fz = u(1)%Fz + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp2(u(1)%PtFairleadLoad, u(2)%PtFairleadLoad, u(3)%PtFairleadLoad, tin, u_out%PtFairleadLoad, tin_out, ErrStat, ErrMsg )
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in MD_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE MD_Output_ExtrapInterp

END MODULE MoorDyn_Types
!ENDOFREGISTRYGENERATEDFILE
